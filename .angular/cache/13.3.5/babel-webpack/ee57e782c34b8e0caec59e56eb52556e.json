{"ast":null,"code":"/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc\n */\nimport { Injectable } from '@angular/core';\nimport { Actions, ofType } from '@ngrx/effects';\nimport { ROUTER_NAVIGATION } from '@ngrx/router-store';\nimport { Store } from '@ngrx/store';\nimport { Observable, of } from 'rxjs';\nimport { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, withLatestFrom } from 'rxjs/operators';\n/**\n * See {\\@link DataPersistence.pessimisticUpdate} for more information.\n * @record\n * @template T, A\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngrx/store';\nimport * as ɵngcc2 from '@ngrx/effects';\nexport function PessimisticUpdateOpts() {}\n\nif (false) {\n  /**\n   * @param {?} a\n   * @param {?=} state\n   * @return {?}\n   */\n  PessimisticUpdateOpts.prototype.run = function (a, state) {};\n  /**\n   * @param {?} a\n   * @param {?} e\n   * @return {?}\n   */\n\n\n  PessimisticUpdateOpts.prototype.onError = function (a, e) {};\n}\n/**\n * See {\\@link DataPersistence.pessimisticUpdate} for more information.\n * @record\n * @template T, A\n */\n\n\nexport function OptimisticUpdateOpts() {}\n\nif (false) {\n  /**\n   * @param {?} a\n   * @param {?=} state\n   * @return {?}\n   */\n  OptimisticUpdateOpts.prototype.run = function (a, state) {};\n  /**\n   * @param {?} a\n   * @param {?} e\n   * @return {?}\n   */\n\n\n  OptimisticUpdateOpts.prototype.undoAction = function (a, e) {};\n}\n/**\n * See {\\@link DataPersistence.fetch} for more information.\n * @record\n * @template T, A\n */\n\n\nexport function FetchOpts() {}\n\nif (false) {\n  /**\n   * @param {?} a\n   * @param {?=} state\n   * @return {?}\n   */\n  FetchOpts.prototype.id = function (a, state) {};\n  /**\n   * @param {?} a\n   * @param {?=} state\n   * @return {?}\n   */\n\n\n  FetchOpts.prototype.run = function (a, state) {};\n  /**\n   * @param {?} a\n   * @param {?} e\n   * @return {?}\n   */\n\n\n  FetchOpts.prototype.onError = function (a, e) {};\n}\n/**\n * See {\\@link DataPersistence.navigation} for more information.\n * @record\n * @template T\n */\n\n\nexport function HandleNavigationOpts() {}\n\nif (false) {\n  /**\n   * @param {?} a\n   * @param {?=} state\n   * @return {?}\n   */\n  HandleNavigationOpts.prototype.run = function (a, state) {};\n  /**\n   * @param {?} a\n   * @param {?} e\n   * @return {?}\n   */\n\n\n  HandleNavigationOpts.prototype.onError = function (a, e) {};\n}\n/**\n * @template T, A\n * @param {?} opts\n * @return {?}\n */\n\n\nexport function pessimisticUpdate(opts) {\n  return source => {\n    return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n/**\n * @template T, A\n * @param {?} opts\n * @return {?}\n */\n\nexport function optimisticUpdate(opts) {\n  return source => {\n    return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));\n  };\n}\n/**\n * @template T, A\n * @param {?} opts\n * @return {?}\n */\n\nexport function fetch(opts) {\n  return source => {\n    if (opts.id) {\n      /** @type {?} */\n      const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, store]) => {\n        return opts.id(action, store);\n      }));\n      return groupedFetches.pipe(mergeMap(pairs => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));\n    }\n\n    return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n/**\n * @template T, A\n * @param {?} component\n * @param {?} opts\n * @return {?}\n */\n\nexport function navigation(component, opts) {\n  return source => {\n    /** @type {?} */\n    const nav = source.pipe(mapActionAndState(), filter(([action, state]) => isStateSnapshot(action)), map(([action, state]) => {\n      if (!isStateSnapshot(action)) {\n        // Because of the above filter we'll never get here,\n        // but this properly type narrows `action`\n        return;\n      }\n\n      return (\n        /** @type {?} */\n        [findSnapshot(component, action.payload.routerState.root), state]\n      );\n    }), filter(([snapshot, state]) => !!snapshot));\n    return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));\n  };\n}\n/**\n * @param {?} action\n * @return {?}\n */\n\nfunction isStateSnapshot(action) {\n  return action.type === ROUTER_NAVIGATION;\n}\n/**\n * @template T, A, R\n * @param {?} run\n * @param {?} onError\n * @return {?}\n */\n\n\nfunction runWithErrorHandling(run, onError) {\n  return ([action, state]) => {\n    try {\n      /** @type {?} */\n      const r = wrapIntoObservable(run(action, state));\n      return r.pipe(catchError(e => wrapIntoObservable(onError(action, e))));\n    } catch (e) {\n      return wrapIntoObservable(onError(action, e));\n    }\n  };\n}\n/**\n * \\@whatItDoes maps Observable<Action | [Action, State]> to\n * Observable<[Action, State]>\n * @template T, A\n * @return {?}\n */\n\n\nfunction mapActionAndState() {\n  return source => {\n    return source.pipe(map(value => {\n      const [action, store] = normalizeActionAndState(value);\n      return (\n        /** @type {?} */\n        [action, store]\n      );\n    }));\n  };\n}\n/**\n * \\@whatItDoes Normalizes either a bare action or an array of action and state\n * into an array of action and state (or undefined)\n * @template T, A\n * @param {?} args\n * @return {?}\n */\n\n\nfunction normalizeActionAndState(args) {\n  /** @type {?} */\n  let action;\n  /** @type {?} */\n\n  let state;\n\n  if (args instanceof Array) {\n    [action, state] = args;\n  } else {\n    action = args;\n  }\n\n  return [action, state];\n}\n/**\n * \\@whatItDoes Provides convenience methods for implementing common operations of persisting data.\n * @template T\n */\n\n\nexport let DataPersistence = /*#__PURE__*/(() => {\n  class DataPersistence {\n    /**\n     * @param {?} store\n     * @param {?} actions\n     */\n    constructor(store, actions) {\n      this.store = store;\n      this.actions = actions;\n    }\n    /**\n     *\n     * \\@whatItDoes Handles pessimistic updates (updating the server first).\n     *\n     * Update the server implemented naively suffers from race conditions and poor error handling.\n     *\n     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * \\@Injectable()\n     * class TodoEffects {\n     * \\@Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n     *     // provides an action and the current state of the store\n     *     run(a, state) {\n     *       // update the backend first, and then dispatch an action that will\n     *       // update the client side\n     *       return this.backend(state.user, a.payload).map(updated => ({\n     *         type: 'TODO_UPDATED',\n     *         payload: updated\n     *       }));\n     *     },\n     *\n     *     onError(a, e: any) {\n     *       // we don't need to undo the changes on the client side.\n     *       // we can dispatch an error, or simply log the error here and return `null`\n     *       return null;\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * Note that if you don't return a new action from the run callback, you must set the dispatch property\n     * of the effect to false, like this:\n     *\n     * ```\n     * class TodoEffects {\n     * \\@Effect({dispatch: false})\n     *   updateTodo; //...\n     * }\n     * ```\n     * @template A\n     * @param {?} actionType\n     * @param {?} opts\n     * @return {?}\n     */\n\n\n    pessimisticUpdate(actionType, opts) {\n      return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));\n    }\n    /**\n     *\n     * \\@whatItDoes Handles optimistic updates (updating the client first).\n     *\n     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,\n     * the developer already updated the state locally, so the developer must provide an undo action.\n     *\n     * The error handling must be done in the callback, or by means of the undo action.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * \\@Injectable()\n     * class TodoEffects {\n     * \\@Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {\n     *     // provides an action and the current state of the store\n     *     run: (a, state) => {\n     *       return this.backend(state.user, a.payload);\n     *     },\n     *\n     *     undoAction: (a, e: any) => {\n     *       // dispatch an undo action to undo the changes in the client state\n     *       return ({\n     *         type: 'UNDO_UPDATE_TODO',\n     *         payload: a\n     *       });\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * Note that if you don't return a new action from the run callback, you must set the dispatch property\n     * of the effect to false, like this:\n     *\n     * ```\n     * class TodoEffects {\n     * \\@Effect({dispatch: false})\n     *   updateTodo; //...\n     * }\n     * ```\n     * @template A\n     * @param {?} actionType\n     * @param {?} opts\n     * @return {?}\n     */\n\n\n    optimisticUpdate(actionType, opts) {\n      return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));\n    }\n    /**\n     *\n     * \\@whatItDoes Handles data fetching.\n     *\n     * Data fetching implemented naively suffers from race conditions and poor error handling.\n     *\n     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions\n     * and forces the developer to handle errors.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * \\@Injectable()\n     * class TodoEffects {\n     * \\@Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {\n     *     // provides an action and the current state of the store\n     *     run: (a, state) => {\n     *       return this.backend(state.user, a.payload).map(r => ({\n     *         type: 'TODOS',\n     *         payload: r\n     *       });\n     *     },\n     *\n     *     onError: (a, e: any) => {\n     *       // dispatch an undo action to undo the changes in the client state\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * This is correct, but because it set the concurrency to 1, it may not be performant.\n     *\n     * To fix that, you can provide the `id` function, like this:\n     *\n     * ```typescript / loadTodo = this.s.fetch<GetTodo>('GET_TODO', {\n     *     id: (a, state) => {\n     *       return a.payload.id;\n     *     }\n     *\n     *     // provides an action and the current state of the store\n     *     run: (a, state) => {\n     *       return this.backend(state.user, a.payload).map(r => ({\n     *         type: 'TODO',\n     *         payload: r\n     *       });\n     *     },\n     *\n     *     onError: (a, e: any) => {\n     *       // dispatch an undo action to undo the changes in the client state\n     *       return null;\n     *     }\n     *   });\n     *\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     *\n     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.\n     *\n     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,\n     * it will only run the last one.\n     * @template A\n     * @param {?} actionType\n     * @param {?} opts\n     * @return {?}\n     */\n\n\n    fetch(actionType, opts) {\n      return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));\n    }\n    /**\n     * \\@whatItDoes Handles data fetching as part of router navigation.\n     *\n     * Data fetching implemented naively suffers from race conditions and poor error handling.\n     *\n     * `navigation` addresses these problems.\n     *\n     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`\n     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs\n     * the last request.\n     *\n     * ## Example:\n     *\n     * ```typescript\n     * \\@Injectable()\n     * class TodoEffects {\n     * \\@Effect() loadTodo = this.s.navigation(TodoComponent, {\n     *     run: (a, state) => {\n     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({\n     *         type: 'TODO_LOADED',\n     *         payload: todo\n     *       }));\n     *     },\n     *     onError: (a, e: any) => {\n     *       // we can log and error here and return null\n     *       // we can also navigate back\n     *       return null;\n     *     }\n     *   });\n     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}\n     * }\n     * ```\n     * @param {?} component\n     * @param {?} opts\n     * @return {?}\n     */\n\n\n    navigation(component, opts) {\n      return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));\n    }\n\n  }\n\n  DataPersistence.ɵfac = function DataPersistence_Factory(t) {\n    return new (t || DataPersistence)(ɵngcc0.ɵɵinject(ɵngcc1.Store), ɵngcc0.ɵɵinject(ɵngcc2.Actions));\n  };\n\n  DataPersistence.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DataPersistence,\n    factory: DataPersistence.ɵfac\n  });\n  /** @nocollapse */\n\n  return DataPersistence;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  DataPersistence.prototype.store;\n  /** @type {?} */\n\n  DataPersistence.prototype.actions;\n}\n/**\n * @param {?} component\n * @param {?} s\n * @return {?}\n */\n\n\nfunction findSnapshot(component, s) {\n  if (s.routeConfig && s.routeConfig.component === component) {\n    return s;\n  }\n\n  for (const c of s.children) {\n    /** @type {?} */\n    const ss = findSnapshot(component, c);\n\n    if (ss) {\n      return ss;\n    }\n  }\n\n  return null;\n}\n/**\n * @template O\n * @param {?} obj\n * @return {?}\n */\n\n\nfunction wrapIntoObservable(obj) {\n  if (!!obj && obj instanceof Observable) {\n    return obj;\n  } else if (!obj) {\n    return of();\n  } else {\n    return of(\n    /** @type {?} */\n    obj);\n  }\n} //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZXMiOlsiQG5yd2wvbngvc3JjL2RhdGEtcGVyc2lzdGVuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFFakQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEQsT0FBTyxFQUFFLGlCQUFpQixFQUEwQixNQUFNLG9CQUFvQixDQUFDO0FBQy9FLE9BQU8sRUFBVSxLQUFLLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDNUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUNMLFVBQVUsRUFDVixTQUFTLEVBQ1QsTUFBTSxFQUNOLE9BQU8sRUFDUCxHQUFHLEVBQ0gsUUFBUSxFQUNSLFNBQVMsRUFDVCxjQUFjLEVBQ2YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QjtBQUNHO0FBRUg7QUFDTztBQUFrQjs7OztBQUF6QiwyQ0FHQztBQUNEO0FBQ1M7QUFBUTtBQUFvQjtBQUF5QjtBQUV4RDtBQUFRLElBTlosOERBQXlEO0FBQzNEO0FBQVE7QUFBb0I7QUFDNUI7QUFFYTtBQUFRLElBSG5CLDhEQUE2QztBQUMvQztBQUNBO0FBQ0E7QUFDQztBQUNPO0FBQWtCO0FBQTFCLDBDQUdDO0FBQ0Q7QUFFUTtBQUFRO0FBQW9CO0FBQ2xDO0FBQ2U7QUFBUSxJQVB2Qiw2REFBeUQ7QUFDM0Q7QUFBUTtBQUFvQjtBQUFvQjtBQUk3QztBQUFRLElBSlQsZ0VBQXNEO0FBQ3hEO0FBQ0E7QUFDRztBQUVIO0FBQ087QUFBa0I7QUFBekIsK0JBSUM7QUFDRDtBQUVRO0FBQVE7QUFBb0I7QUFBeUI7QUFFakQ7QUFBUSxJQVJsQixpREFBMEI7QUFDNUI7QUFBUTtBQUFvQjtBQUF5QjtBQUN6QztBQUFRLElBRGxCLGtEQUF5RDtBQUMzRDtBQUFRO0FBQW9CO0FBQW9C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Y2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBSb3V0ZXJTdGF0ZVNuYXBzaG90IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEFjdGlvbnMsIG9mVHlwZSB9IGZyb20gJ0BuZ3J4L2VmZmVjdHMnO1xuaW1wb3J0IHsgUk9VVEVSX05BVklHQVRJT04sIFJvdXRlck5hdmlnYXRpb25BY3Rpb24gfSBmcm9tICdAbmdyeC9yb3V0ZXItc3RvcmUnO1xuaW1wb3J0IHsgQWN0aW9uLCBTdG9yZSB9IGZyb20gJ0BuZ3J4L3N0b3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBjb25jYXRNYXAsXG4gIGZpbHRlcixcbiAgZ3JvdXBCeSxcbiAgbWFwLFxuICBtZXJnZU1hcCxcbiAgc3dpdGNoTWFwLFxuICB3aXRoTGF0ZXN0RnJvbVxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UucGVzc2ltaXN0aWNVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPiB7XG4gIHJ1bihhOiBBLCBzdGF0ZT86IFQpOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yKGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cbi8qKlxuICogU2VlIHtAbGluayBEYXRhUGVyc2lzdGVuY2UucGVzc2ltaXN0aWNVcGRhdGV9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+IHtcbiAgcnVuKGE6IEEsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIHVuZG9BY3Rpb24oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uO1xufVxuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLmZldGNofSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdHM8VCwgQT4ge1xuICBpZD8oYTogQSwgc3RhdGU/OiBUKTogYW55O1xuICBydW4oYTogQSwgc3RhdGU/OiBUKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG4vKipcbiAqIFNlZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlLm5hdmlnYXRpb259IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+IHtcbiAgcnVuKGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIHN0YXRlPzogVCk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3I/KGE6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIGU6IGFueSk6IE9ic2VydmFibGU8YW55PiB8IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4gPSBBIHwgW0EsIFRdO1xuZXhwb3J0IHR5cGUgQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4gPSBPYnNlcnZhYmxlPEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlPFQsIEE+PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBlc3NpbWlzdGljVXBkYXRlPFQsIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbikge1xuICByZXR1cm4gKHNvdXJjZTogQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMub25FcnJvcikpXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGltaXN0aWNVcGRhdGU8VCwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIG9wdHM6IE9wdGltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgY29uY2F0TWFwKHJ1bldpdGhFcnJvckhhbmRsaW5nKG9wdHMucnVuLCBvcHRzLnVuZG9BY3Rpb24pKVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaDxULCBBIGV4dGVuZHMgQWN0aW9uPihvcHRzOiBGZXRjaE9wdHM8VCwgQT4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KTogT2JzZXJ2YWJsZTxBY3Rpb24+ID0+IHtcbiAgICBpZiAob3B0cy5pZCkge1xuICAgICAgY29uc3QgZ3JvdXBlZEZldGNoZXMgPSBzb3VyY2UucGlwZShcbiAgICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgICAgZ3JvdXBCeSgoW2FjdGlvbiwgc3RvcmVdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdHMuaWQoYWN0aW9uLCBzdG9yZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gZ3JvdXBlZEZldGNoZXMucGlwZShcbiAgICAgICAgbWVyZ2VNYXAocGFpcnMgPT5cbiAgICAgICAgICBwYWlycy5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGlvbjxULCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gIG9wdHM6IEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlU3RyZWFtPFQsIEE+KSA9PiB7XG4gICAgY29uc3QgbmF2ID0gc291cmNlLnBpcGUoXG4gICAgICBtYXBBY3Rpb25BbmRTdGF0ZSgpLFxuICAgICAgZmlsdGVyKChbYWN0aW9uLCBzdGF0ZV0pID0+IGlzU3RhdGVTbmFwc2hvdChhY3Rpb24pKSxcbiAgICAgIG1hcCgoW2FjdGlvbiwgc3RhdGVdKSA9PiB7XG4gICAgICAgIGlmICghaXNTdGF0ZVNuYXBzaG90KGFjdGlvbikpIHtcbiAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSBhYm92ZSBmaWx0ZXIgd2UnbGwgbmV2ZXIgZ2V0IGhlcmUsXG4gICAgICAgICAgLy8gYnV0IHRoaXMgcHJvcGVybHkgdHlwZSBuYXJyb3dzIGBhY3Rpb25gXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBmaW5kU25hcHNob3QoY29tcG9uZW50LCBhY3Rpb24ucGF5bG9hZC5yb3V0ZXJTdGF0ZS5yb290KSxcbiAgICAgICAgICBzdGF0ZVxuICAgICAgICBdIGFzIFtBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBUXTtcbiAgICAgIH0pLFxuICAgICAgZmlsdGVyKChbc25hcHNob3QsIHN0YXRlXSkgPT4gISFzbmFwc2hvdClcbiAgICApO1xuXG4gICAgcmV0dXJuIG5hdi5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlU25hcHNob3QoXG4gIGFjdGlvbjogYW55XG4pOiBhY3Rpb24gaXMgUm91dGVyTmF2aWdhdGlvbkFjdGlvbjxSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gIHJldHVybiBhY3Rpb24udHlwZSA9PT0gUk9VVEVSX05BVklHQVRJT047XG59XG5cbmZ1bmN0aW9uIHJ1bldpdGhFcnJvckhhbmRsaW5nPFQsIEEsIFI+KFxuICBydW46IChhOiBBLCBzdGF0ZT86IFQpID0+IE9ic2VydmFibGU8Uj4gfCBSIHwgdm9pZCxcbiAgb25FcnJvcjogYW55XG4pIHtcbiAgcmV0dXJuIChbYWN0aW9uLCBzdGF0ZV06IFtBLCBUXSk6IE9ic2VydmFibGU8Uj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByID0gd3JhcEludG9PYnNlcnZhYmxlKHJ1bihhY3Rpb24sIHN0YXRlKSk7XG4gICAgICByZXR1cm4gci5waXBlKGNhdGNoRXJyb3IoZSA9PiB3cmFwSW50b09ic2VydmFibGUob25FcnJvcihhY3Rpb24sIGUpKSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUob25FcnJvcihhY3Rpb24sIGUpKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgbWFwcyBPYnNlcnZhYmxlPEFjdGlvbiB8IFtBY3Rpb24sIFN0YXRlXT4gdG9cbiAqIE9ic2VydmFibGU8W0FjdGlvbiwgU3RhdGVdPlxuICovXG5mdW5jdGlvbiBtYXBBY3Rpb25BbmRTdGF0ZTxULCBBPigpIHtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8QWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4+KSA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwKHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgW2FjdGlvbiwgc3RvcmVdID0gbm9ybWFsaXplQWN0aW9uQW5kU3RhdGUodmFsdWUpO1xuICAgICAgICByZXR1cm4gW2FjdGlvbiwgc3RvcmVdIGFzIFtBLCBUXTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBOb3JtYWxpemVzIGVpdGhlciBhIGJhcmUgYWN0aW9uIG9yIGFuIGFycmF5IG9mIGFjdGlvbiBhbmQgc3RhdGVcbiAqIGludG8gYW4gYXJyYXkgb2YgYWN0aW9uIGFuZCBzdGF0ZSAob3IgdW5kZWZpbmVkKVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBY3Rpb25BbmRTdGF0ZTxULCBBPihcbiAgYXJnczogQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT5cbik6IFtBLCBUXSB7XG4gIGxldCBhY3Rpb246IEEsIHN0YXRlOiBUO1xuXG4gIGlmIChhcmdzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBbYWN0aW9uLCBzdGF0ZV0gPSBhcmdzO1xuICB9IGVsc2Uge1xuICAgIGFjdGlvbiA9IGFyZ3M7XG4gIH1cblxuICByZXR1cm4gW2FjdGlvbiwgc3RhdGVdO1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIFByb3ZpZGVzIGNvbnZlbmllbmNlIG1ldGhvZHMgZm9yIGltcGxlbWVudGluZyBjb21tb24gb3BlcmF0aW9ucyBvZiBwZXJzaXN0aW5nIGRhdGEuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhUGVyc2lzdGVuY2U8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RvcmU6IFN0b3JlPFQ+LCBwdWJsaWMgYWN0aW9uczogQWN0aW9ucykge31cblxuICAvKipcbiAgICpcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBwZXNzaW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgc2VydmVyIGZpcnN0KS5cbiAgICpcbiAgICogVXBkYXRlIHRoZSBzZXJ2ZXIgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBgcGVzc2ltaXN0aWNVcGRhdGVgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqICMjIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogQEluamVjdGFibGUoKVxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCgpIHVwZGF0ZVRvZG8gPSB0aGlzLnMucGVzc2ltaXN0aWNVcGRhdGU8VXBkYXRlVG9kbz4oJ1VQREFURV9UT0RPJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bihhLCBzdGF0ZSkge1xuICAgKiAgICAgICAvLyB1cGRhdGUgdGhlIGJhY2tlbmQgZmlyc3QsIGFuZCB0aGVuIGRpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IHdpbGxcbiAgICogICAgICAgLy8gdXBkYXRlIHRoZSBjbGllbnQgc2lkZVxuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCkubWFwKHVwZGF0ZWQgPT4gKHtcbiAgICogICAgICAgICB0eXBlOiAnVE9ET19VUERBVEVEJyxcbiAgICogICAgICAgICBwYXlsb2FkOiB1cGRhdGVkXG4gICAqICAgICAgIH0pKTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yKGEsIGU6IGFueSkge1xuICAgKiAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHVuZG8gdGhlIGNoYW5nZXMgb24gdGhlIGNsaWVudCBzaWRlLlxuICAgKiAgICAgICAvLyB3ZSBjYW4gZGlzcGF0Y2ggYW4gZXJyb3IsIG9yIHNpbXBseSBsb2cgdGhlIGVycm9yIGhlcmUgYW5kIHJldHVybiBgbnVsbGBcbiAgICogICAgICAgcmV0dXJuIG51bGw7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICAgKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICogICB1cGRhdGVUb2RvOyAvLy4uLlxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgcGVzc2ltaXN0aWNVcGRhdGU8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nLFxuICAgIG9wdHM6IFBlc3NpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgcGVzc2ltaXN0aWNVcGRhdGUob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgb3B0aW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgY2xpZW50IGZpcnN0KS5cbiAgICpcbiAgICogYG9wdGltaXN0aWNVcGRhdGVgIGFkZHJlc3NlcyB0aGVzZSBwcm9ibGVtcy0taXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnNcbiAgICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gICAqXG4gICAqIGBvcHRpbWlzdGljVXBkYXRlYCBpcyBkaWZmZXJlbnQgZnJvbSBgcGVzc2ltaXN0aWNVcGRhdGVgLiBJbiBjYXNlIG9mIGEgZmFpbHVyZSwgd2hlbiB1c2luZyBgb3B0aW1pc3RpY1VwZGF0ZWAsXG4gICAqIHRoZSBkZXZlbG9wZXIgYWxyZWFkeSB1cGRhdGVkIHRoZSBzdGF0ZSBsb2NhbGx5LCBzbyB0aGUgZGV2ZWxvcGVyIG11c3QgcHJvdmlkZSBhbiB1bmRvIGFjdGlvbi5cbiAgICpcbiAgICogVGhlIGVycm9yIGhhbmRsaW5nIG11c3QgYmUgZG9uZSBpbiB0aGUgY2FsbGJhY2ssIG9yIGJ5IG1lYW5zIG9mIHRoZSB1bmRvIGFjdGlvbi5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgdXBkYXRlVG9kbyA9IHRoaXMucy5vcHRpbWlzdGljVXBkYXRlPFVwZGF0ZVRvZG8+KCdVUERBVEVfVE9ETycsIHtcbiAgICogICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAqICAgICBydW46IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kKHN0YXRlLnVzZXIsIGEucGF5bG9hZCk7XG4gICAqICAgICB9LFxuICAgKlxuICAgKiAgICAgdW5kb0FjdGlvbjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAgICogICAgICAgcmV0dXJuICh7XG4gICAqICAgICAgICAgdHlwZTogJ1VORE9fVVBEQVRFX1RPRE8nLFxuICAgKiAgICAgICAgIHBheWxvYWQ6IGFcbiAgICogICAgICAgfSk7XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBzOiBEYXRhUGVyc2lzdGVuY2U8VG9kb3NTdGF0ZT4sIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkb24ndCByZXR1cm4gYSBuZXcgYWN0aW9uIGZyb20gdGhlIHJ1biBjYWxsYmFjaywgeW91IG11c3Qgc2V0IHRoZSBkaXNwYXRjaCBwcm9wZXJ0eVxuICAgKiBvZiB0aGUgZWZmZWN0IHRvIGZhbHNlLCBsaWtlIHRoaXM6XG4gICAqXG4gICAqIGBgYFxuICAgKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gICAqICAgQEVmZmVjdCh7ZGlzcGF0Y2g6IGZhbHNlfSlcbiAgICogICB1cGRhdGVUb2RvOyAvLy4uLlxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb3B0aW1pc3RpY1VwZGF0ZTxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcsXG4gICAgb3B0czogT3B0aW1pc3RpY1VwZGF0ZU9wdHM8VCwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIG9wdGltaXN0aWNVcGRhdGUob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZy5cbiAgICpcbiAgICogRGF0YSBmZXRjaGluZyBpbXBsZW1lbnRlZCBuYWl2ZWx5IHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIGBmZXRjaGAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLS1pdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICAgKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAgICpcbiAgICogIyMgRXhhbXBsZTpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG9zID0gdGhpcy5zLmZldGNoPEdldFRvZG9zPignR0VUX1RPRE9TJywge1xuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAociA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPUycsXG4gICAqICAgICAgICAgcGF5bG9hZDogclxuICAgKiAgICAgICB9KTtcbiAgICogICAgIH0sXG4gICAqXG4gICAqICAgICBvbkVycm9yOiAoYSwgZTogYW55KSA9PiB7XG4gICAqICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFRoaXMgaXMgY29ycmVjdCwgYnV0IGJlY2F1c2UgaXQgc2V0IHRoZSBjb25jdXJyZW5jeSB0byAxLCBpdCBtYXkgbm90IGJlIHBlcmZvcm1hbnQuXG4gICAqXG4gICAqIFRvIGZpeCB0aGF0LCB5b3UgY2FuIHByb3ZpZGUgdGhlIGBpZGAgZnVuY3Rpb24sIGxpa2UgdGhpczpcbiAgICpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBASW5qZWN0YWJsZSgpXG4gICAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAgICogICBARWZmZWN0KCkgbG9hZFRvZG8gPSB0aGlzLnMuZmV0Y2g8R2V0VG9kbz4oJ0dFVF9UT0RPJywge1xuICAgKiAgICAgaWQ6IChhLCBzdGF0ZSkgPT4ge1xuICAgKiAgICAgICByZXR1cm4gYS5wYXlsb2FkLmlkO1xuICAgKiAgICAgfVxuICAgKlxuICAgKiAgICAgLy8gcHJvdmlkZXMgYW4gYWN0aW9uIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc3RvcmVcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQoc3RhdGUudXNlciwgYS5wYXlsb2FkKS5tYXAociA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPJyxcbiAgICogICAgICAgICBwYXlsb2FkOiByXG4gICAqICAgICAgIH0pO1xuICAgKiAgICAgfSxcbiAgICpcbiAgICogICAgIG9uRXJyb3I6IChhLCBlOiBhbnkpID0+IHtcbiAgICogICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFdpdGggdGhpcyBzZXR1cCwgdGhlIHJlcXVlc3RzIGZvciBUb2RvIDEgd2lsbCBydW4gY29uY3VycmVudGx5IHdpdGggdGhlIHJlcXVlc3RzIGZvciBUb2RvIDIuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uLCBpZiBEYXRhUGVyc2lzdGVuY2Ugbm90aWNlcyB0aGF0IHRoZXJlIGFyZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgVG9kbyAxIHNjaGVkdWxlZCxcbiAgICogaXQgd2lsbCBvbmx5IHJ1biB0aGUgbGFzdCBvbmUuXG4gICAqL1xuICBmZXRjaDxBIGV4dGVuZHMgQWN0aW9uID0gQWN0aW9uPihcbiAgICBhY3Rpb25UeXBlOiBzdHJpbmcsXG4gICAgb3B0czogRmV0Y2hPcHRzPFQsIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBmZXRjaChvcHRzKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHdoYXRJdERvZXMgSGFuZGxlcyBkYXRhIGZldGNoaW5nIGFzIHBhcnQgb2Ygcm91dGVyIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICAgKlxuICAgKiBgbmF2aWdhdGlvbmAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLlxuICAgKlxuICAgKiBJdCBjaGVja3MgaWYgYW4gYWN0aXZhdGVkIHJvdXRlciBzdGF0ZSBjb250YWlucyB0aGUgcGFzc2VkIGluIGNvbXBvbmVudCB0eXBlLCBhbmQsIGlmIGl0IGRvZXMsIHJ1bnMgdGhlIGBydW5gXG4gICAqIGNhbGxiYWNrLiBJdCBwcm92aWRlcyB0aGUgYWN0aXZhdGVkIHNuYXBzaG90IGFzc29jaWF0ZWQgd2l0aCB0aGUgY29tcG9uZW50IGFuZCB0aGUgY3VycmVudCBzdGF0ZS4gQW5kIGl0IG9ubHkgcnVuc1xuICAgKiB0aGUgbGFzdCByZXF1ZXN0LlxuICAgKlxuICAgKiAjIyBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIEBJbmplY3RhYmxlKClcbiAgICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICAgKiAgIEBFZmZlY3QoKSBsb2FkVG9kbyA9IHRoaXMucy5uYXZpZ2F0aW9uKFRvZG9Db21wb25lbnQsIHtcbiAgICogICAgIHJ1bjogKGEsIHN0YXRlKSA9PiB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQuZmV0Y2hUb2RvKGEucGFyYW1zWydpZCddKS5tYXAodG9kbyA9PiAoe1xuICAgKiAgICAgICAgIHR5cGU6ICdUT0RPX0xPQURFRCcsXG4gICAqICAgICAgICAgcGF5bG9hZDogdG9kb1xuICAgKiAgICAgICB9KSk7XG4gICAqICAgICB9LFxuICAgKiAgICAgb25FcnJvcjogKGEsIGU6IGFueSkgPT4ge1xuICAgKiAgICAgICAvLyB3ZSBjYW4gbG9nIGFuZCBlcnJvciBoZXJlIGFuZCByZXR1cm4gbnVsbFxuICAgKiAgICAgICAvLyB3ZSBjYW4gYWxzbyBuYXZpZ2F0ZSBiYWNrXG4gICAqICAgICAgIHJldHVybiBudWxsO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgczogRGF0YVBlcnNpc3RlbmNlPFRvZG9zU3RhdGU+LCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBuYXZpZ2F0aW9uKFxuICAgIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICAgIG9wdHM6IEhhbmRsZU5hdmlnYXRpb25PcHRzPFQ+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBuYXZpZ2F0aW9uKGNvbXBvbmVudCwgb3B0cylcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTbmFwc2hvdChcbiAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gIHM6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Rcbik6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Qge1xuICBpZiAocy5yb3V0ZUNvbmZpZyAmJiBzLnJvdXRlQ29uZmlnLmNvbXBvbmVudCA9PT0gY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZm9yIChjb25zdCBjIG9mIHMuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzcyA9IGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGMpO1xuICAgIGlmIChzcykge1xuICAgICAgcmV0dXJuIHNzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gd3JhcEludG9PYnNlcnZhYmxlPE8+KG9iajogT2JzZXJ2YWJsZTxPPiB8IE8gfCB2b2lkKTogT2JzZXJ2YWJsZTxPPiB7XG4gIGlmICghIW9iaiAmJiBvYmogaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfSBlbHNlIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIG9mKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9mKG9iaiBhcyBPKTtcbiAgfVxufVxuIl19","map":null,"metadata":{},"sourceType":"module"}