{"ast":null,"code":"import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, forwardRef, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Attribute, Optional, Inject, Input, Output, ViewChild, Directive, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, CheckboxRequiredValidator } from '@angular/forms';\nimport * as i2 from '@angular/material/core';\nimport { mixinTabIndex, mixinColor, mixinDisableRipple, mixinDisabled, MatRipple, MatRippleModule, MatCommonModule } from '@angular/material/core';\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\nimport * as i1 from '@angular/cdk/a11y';\nimport * as i3 from '@angular/cdk/observers';\nimport { ObserversModule } from '@angular/cdk/observers';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Injection token to be used to override the default options for `mat-checkbox`. */\n\nconst _c0 = [\"input\"];\n\nconst _c1 = function (a0) {\n  return {\n    enterDuration: a0\n  };\n};\n\nconst _c2 = [\"*\"];\nconst MAT_CHECKBOX_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('mat-checkbox-default-options', {\n  providedIn: 'root',\n  factory: MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY\n});\n/** @docs-private */\n\nfunction MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY() {\n  return {\n    color: 'accent',\n    clickAction: 'check-indeterminate'\n  };\n} // Increasing integer for generating unique ids for checkbox components.\n\n\nlet nextUniqueId = 0; // Default checkbox configuration.\n\nconst defaults = /*#__PURE__*/MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY();\n/**\n * Provider Expression that allows mat-checkbox to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\n\nconst MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(() => MatCheckbox),\n  multi: true\n};\n/** Change event object emitted by MatCheckbox. */\n\nclass MatCheckboxChange {} // Boilerplate for applying mixins to MatCheckbox.\n\n/** @docs-private */\n\n\nconst _MatCheckboxBase = /*#__PURE__*/mixinTabIndex( /*#__PURE__*/mixinColor( /*#__PURE__*/mixinDisableRipple( /*#__PURE__*/mixinDisabled(class {\n  constructor(_elementRef) {\n    this._elementRef = _elementRef;\n  }\n\n}))));\n/**\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\n * and exposes a similar API. A MatCheckbox can be either checked, unchecked, indeterminate, or\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\n * so there is no need to provide them yourself. However, if you want to omit a label and still\n * have the checkbox be accessible, you may supply an [aria-label] input.\n * See: https://material.io/design/components/selection-controls.html\n */\n\n\nlet MatCheckbox = /*#__PURE__*/(() => {\n  class MatCheckbox extends _MatCheckboxBase {\n    constructor(elementRef, _changeDetectorRef, _focusMonitor, _ngZone, tabIndex, _animationMode, _options) {\n      super(elementRef);\n      this._changeDetectorRef = _changeDetectorRef;\n      this._focusMonitor = _focusMonitor;\n      this._ngZone = _ngZone;\n      this._animationMode = _animationMode;\n      this._options = _options;\n      /**\n       * Attached to the aria-label attribute of the host element. In most cases, aria-labelledby will\n       * take precedence so this may be omitted.\n       */\n\n      this.ariaLabel = '';\n      /**\n       * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n       */\n\n      this.ariaLabelledby = null;\n      this._uniqueId = `mat-checkbox-${++nextUniqueId}`;\n      /** A unique id for the checkbox input. If none is supplied, it will be auto-generated. */\n\n      this.id = this._uniqueId;\n      /** Whether the label should appear after or before the checkbox. Defaults to 'after' */\n\n      this.labelPosition = 'after';\n      /** Name value will be applied to the input element if present */\n\n      this.name = null;\n      /** Event emitted when the checkbox's `checked` value changes. */\n\n      this.change = new EventEmitter();\n      /** Event emitted when the checkbox's `indeterminate` value changes. */\n\n      this.indeterminateChange = new EventEmitter();\n      /**\n       * Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor.\n       * @docs-private\n       */\n\n      this._onTouched = () => {};\n\n      this._currentAnimationClass = '';\n      this._currentCheckState = 0\n      /* Init */\n      ;\n\n      this._controlValueAccessorChangeFn = () => {};\n\n      this._checked = false;\n      this._disabled = false;\n      this._indeterminate = false;\n      this._options = this._options || defaults;\n      this.color = this.defaultColor = this._options.color || defaults.color;\n      this.tabIndex = parseInt(tabIndex) || 0;\n    }\n    /** Returns the unique id for the visual hidden input. */\n\n\n    get inputId() {\n      return `${this.id || this._uniqueId}-input`;\n    }\n    /** Whether the checkbox is required. */\n\n\n    get required() {\n      return this._required;\n    }\n\n    set required(value) {\n      this._required = coerceBooleanProperty(value);\n    }\n\n    ngAfterViewInit() {\n      this._focusMonitor.monitor(this._elementRef, true).subscribe(focusOrigin => {\n        if (!focusOrigin) {\n          // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n          // Angular does not expect events to be raised during change detection, so any state change\n          // (such as a form control's 'ng-touched') will cause a changed-after-checked error.\n          // See https://github.com/angular/angular/issues/17793. To work around this, we defer\n          // telling the form control it has been touched until the next tick.\n          Promise.resolve().then(() => {\n            this._onTouched();\n\n            this._changeDetectorRef.markForCheck();\n          });\n        }\n      });\n\n      this._syncIndeterminate(this._indeterminate);\n    } // TODO: Delete next major revision.\n\n\n    ngAfterViewChecked() {}\n\n    ngOnDestroy() {\n      this._focusMonitor.stopMonitoring(this._elementRef);\n    }\n    /**\n     * Whether the checkbox is checked.\n     */\n\n\n    get checked() {\n      return this._checked;\n    }\n\n    set checked(value) {\n      const checked = coerceBooleanProperty(value);\n\n      if (checked != this.checked) {\n        this._checked = checked;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * Whether the checkbox is disabled. This fully overrides the implementation provided by\n     * mixinDisabled, but the mixin is still required because mixinTabIndex requires it.\n     */\n\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      const newValue = coerceBooleanProperty(value);\n\n      if (newValue !== this.disabled) {\n        this._disabled = newValue;\n\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    /**\n     * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n     * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n     * checkable items. Note that whenever checkbox is manually clicked, indeterminate is immediately\n     * set to false.\n     */\n\n\n    get indeterminate() {\n      return this._indeterminate;\n    }\n\n    set indeterminate(value) {\n      const changed = value != this._indeterminate;\n      this._indeterminate = coerceBooleanProperty(value);\n\n      if (changed) {\n        if (this._indeterminate) {\n          this._transitionCheckState(3\n          /* Indeterminate */\n          );\n        } else {\n          this._transitionCheckState(this.checked ? 1\n          /* Checked */\n          : 2\n          /* Unchecked */\n          );\n        }\n\n        this.indeterminateChange.emit(this._indeterminate);\n      }\n\n      this._syncIndeterminate(this._indeterminate);\n    }\n\n    _isRippleDisabled() {\n      return this.disableRipple || this.disabled;\n    }\n    /** Method being called whenever the label text changes. */\n\n\n    _onLabelTextChange() {\n      // Since the event of the `cdkObserveContent` directive runs outside of the zone, the checkbox\n      // component will be only marked for check, but no actual change detection runs automatically.\n      // Instead of going back into the zone in order to trigger a change detection which causes\n      // *all* components to be checked (if explicitly marked or not using OnPush), we only trigger\n      // an explicit change detection for the checkbox view and its children.\n      this._changeDetectorRef.detectChanges();\n    } // Implemented as part of ControlValueAccessor.\n\n\n    writeValue(value) {\n      this.checked = !!value;\n    } // Implemented as part of ControlValueAccessor.\n\n\n    registerOnChange(fn) {\n      this._controlValueAccessorChangeFn = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    } // Implemented as part of ControlValueAccessor.\n\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n    _getAriaChecked() {\n      if (this.checked) {\n        return 'true';\n      }\n\n      return this.indeterminate ? 'mixed' : 'false';\n    }\n\n    _transitionCheckState(newState) {\n      let oldState = this._currentCheckState;\n      let element = this._elementRef.nativeElement;\n\n      if (oldState === newState) {\n        return;\n      }\n\n      if (this._currentAnimationClass.length > 0) {\n        element.classList.remove(this._currentAnimationClass);\n      }\n\n      this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\n      this._currentCheckState = newState;\n\n      if (this._currentAnimationClass.length > 0) {\n        element.classList.add(this._currentAnimationClass); // Remove the animation class to avoid animation when the checkbox is moved between containers\n\n        const animationClass = this._currentAnimationClass;\n\n        this._ngZone.runOutsideAngular(() => {\n          setTimeout(() => {\n            element.classList.remove(animationClass);\n          }, 1000);\n        });\n      }\n    }\n\n    _emitChangeEvent() {\n      const event = new MatCheckboxChange();\n      event.source = this;\n      event.checked = this.checked;\n\n      this._controlValueAccessorChangeFn(this.checked);\n\n      this.change.emit(event); // Assigning the value again here is redundant, but we have to do it in case it was\n      // changed inside the `change` listener which will cause the input to be out of sync.\n\n      if (this._inputElement) {\n        this._inputElement.nativeElement.checked = this.checked;\n      }\n    }\n    /** Toggles the `checked` state of the checkbox. */\n\n\n    toggle() {\n      this.checked = !this.checked;\n\n      this._controlValueAccessorChangeFn(this.checked);\n    }\n    /**\n     * Event handler for checkbox input element.\n     * Toggles checked state if element is not disabled.\n     * Do not toggle on (change) event since IE doesn't fire change event when\n     *   indeterminate checkbox is clicked.\n     * @param event\n     */\n\n\n    _onInputClick(event) {\n      var _a;\n\n      const clickAction = (_a = this._options) === null || _a === void 0 ? void 0 : _a.clickAction; // We have to stop propagation for click events on the visual hidden input element.\n      // By default, when a user clicks on a label element, a generated click event will be\n      // dispatched on the associated input element. Since we are using a label element as our\n      // root container, the click event on the `checkbox` will be executed twice.\n      // The real click event will bubble up, and the generated click event also tries to bubble up.\n      // This will lead to multiple click events.\n      // Preventing bubbling for the second event will solve that issue.\n\n      event.stopPropagation(); // If resetIndeterminate is false, and the current state is indeterminate, do nothing on click\n\n      if (!this.disabled && clickAction !== 'noop') {\n        // When user manually click on the checkbox, `indeterminate` is set to false.\n        if (this.indeterminate && clickAction !== 'check') {\n          Promise.resolve().then(() => {\n            this._indeterminate = false;\n            this.indeterminateChange.emit(this._indeterminate);\n          });\n        }\n\n        this._checked = !this._checked;\n\n        this._transitionCheckState(this._checked ? 1\n        /* Checked */\n        : 2\n        /* Unchecked */\n        ); // Emit our custom change event if the native input emitted one.\n        // It is important to only emit it, if the native input triggered one, because\n        // we don't want to trigger a change event, when the `checked` variable changes for example.\n\n\n        this._emitChangeEvent();\n      } else if (!this.disabled && clickAction === 'noop') {\n        // Reset native input when clicked with noop. The native checkbox becomes checked after\n        // click, reset it to be align with `checked` value of `mat-checkbox`.\n        this._inputElement.nativeElement.checked = this.checked;\n        this._inputElement.nativeElement.indeterminate = this.indeterminate;\n      }\n    }\n    /** Focuses the checkbox. */\n\n\n    focus(origin, options) {\n      if (origin) {\n        this._focusMonitor.focusVia(this._inputElement, origin, options);\n      } else {\n        this._inputElement.nativeElement.focus(options);\n      }\n    }\n\n    _onInteractionEvent(event) {\n      // We always have to stop propagation on the change event.\n      // Otherwise the change event, from the input element, will bubble up and\n      // emit its event object to the `change` output.\n      event.stopPropagation();\n    }\n\n    _getAnimationClassForCheckStateTransition(oldState, newState) {\n      // Don't transition if animations are disabled.\n      if (this._animationMode === 'NoopAnimations') {\n        return '';\n      }\n\n      let animSuffix = '';\n\n      switch (oldState) {\n        case 0\n        /* Init */\n        :\n          // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n          // [checked] bound to it.\n          if (newState === 1\n          /* Checked */\n          ) {\n            animSuffix = 'unchecked-checked';\n          } else if (newState == 3\n          /* Indeterminate */\n          ) {\n            animSuffix = 'unchecked-indeterminate';\n          } else {\n            return '';\n          }\n\n          break;\n\n        case 2\n        /* Unchecked */\n        :\n          animSuffix = newState === 1\n          /* Checked */\n          ? 'unchecked-checked' : 'unchecked-indeterminate';\n          break;\n\n        case 1\n        /* Checked */\n        :\n          animSuffix = newState === 2\n          /* Unchecked */\n          ? 'checked-unchecked' : 'checked-indeterminate';\n          break;\n\n        case 3\n        /* Indeterminate */\n        :\n          animSuffix = newState === 1\n          /* Checked */\n          ? 'indeterminate-checked' : 'indeterminate-unchecked';\n          break;\n      }\n\n      return `mat-checkbox-anim-${animSuffix}`;\n    }\n    /**\n     * Syncs the indeterminate value with the checkbox DOM node.\n     *\n     * We sync `indeterminate` directly on the DOM node, because in Ivy the check for whether a\n     * property is supported on an element boils down to `if (propName in element)`. Domino's\n     * HTMLInputElement doesn't have an `indeterminate` property so Ivy will warn during\n     * server-side rendering.\n     */\n\n\n    _syncIndeterminate(value) {\n      const nativeCheckbox = this._inputElement;\n\n      if (nativeCheckbox) {\n        nativeCheckbox.nativeElement.indeterminate = value;\n      }\n    }\n\n  }\n\n  MatCheckbox.ɵfac = function MatCheckbox_Factory(t) {\n    return new (t || MatCheckbox)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.FocusMonitor), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵinjectAttribute('tabindex'), i0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), i0.ɵɵdirectiveInject(MAT_CHECKBOX_DEFAULT_OPTIONS, 8));\n  };\n\n  MatCheckbox.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MatCheckbox,\n    selectors: [[\"mat-checkbox\"]],\n    viewQuery: function MatCheckbox_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(MatRipple, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._inputElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.ripple = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mat-checkbox\"],\n    hostVars: 14,\n    hostBindings: function MatCheckbox_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.id);\n        i0.ɵɵattribute(\"tabindex\", null)(\"aria-label\", null)(\"aria-labelledby\", null);\n        i0.ɵɵclassProp(\"mat-checkbox-indeterminate\", ctx.indeterminate)(\"mat-checkbox-checked\", ctx.checked)(\"mat-checkbox-disabled\", ctx.disabled)(\"mat-checkbox-label-before\", ctx.labelPosition == \"before\")(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n      }\n    },\n    inputs: {\n      disableRipple: \"disableRipple\",\n      color: \"color\",\n      tabIndex: \"tabIndex\",\n      ariaLabel: [\"aria-label\", \"ariaLabel\"],\n      ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"],\n      ariaDescribedby: [\"aria-describedby\", \"ariaDescribedby\"],\n      id: \"id\",\n      required: \"required\",\n      labelPosition: \"labelPosition\",\n      name: \"name\",\n      value: \"value\",\n      checked: \"checked\",\n      disabled: \"disabled\",\n      indeterminate: \"indeterminate\"\n    },\n    outputs: {\n      change: \"change\",\n      indeterminateChange: \"indeterminateChange\"\n    },\n    exportAs: [\"matCheckbox\"],\n    features: [i0.ɵɵProvidersFeature([MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c2,\n    decls: 17,\n    vars: 21,\n    consts: [[1, \"mat-checkbox-layout\"], [\"label\", \"\"], [1, \"mat-checkbox-inner-container\"], [\"type\", \"checkbox\", 1, \"mat-checkbox-input\", \"cdk-visually-hidden\", 3, \"id\", \"required\", \"checked\", \"disabled\", \"tabIndex\", \"change\", \"click\"], [\"input\", \"\"], [\"matRipple\", \"\", 1, \"mat-checkbox-ripple\", \"mat-focus-indicator\", 3, \"matRippleTrigger\", \"matRippleDisabled\", \"matRippleRadius\", \"matRippleCentered\", \"matRippleAnimation\"], [1, \"mat-ripple-element\", \"mat-checkbox-persistent-ripple\"], [1, \"mat-checkbox-frame\"], [1, \"mat-checkbox-background\"], [\"version\", \"1.1\", \"focusable\", \"false\", \"viewBox\", \"0 0 24 24\", \"aria-hidden\", \"true\", 1, \"mat-checkbox-checkmark\"], [\"fill\", \"none\", \"stroke\", \"white\", \"d\", \"M4.1,12.7 9,17.6 20.3,6.3\", 1, \"mat-checkbox-checkmark-path\"], [1, \"mat-checkbox-mixedmark\"], [1, \"mat-checkbox-label\", 3, \"cdkObserveContent\"], [\"checkboxLabel\", \"\"], [2, \"display\", \"none\"]],\n    template: function MatCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"label\", 0, 1)(2, \"span\", 2)(3, \"input\", 3, 4);\n        i0.ɵɵlistener(\"change\", function MatCheckbox_Template_input_change_3_listener($event) {\n          return ctx._onInteractionEvent($event);\n        })(\"click\", function MatCheckbox_Template_input_click_3_listener($event) {\n          return ctx._onInputClick($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"span\", 5);\n        i0.ɵɵelement(6, \"span\", 6);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(7, \"span\", 7);\n        i0.ɵɵelementStart(8, \"span\", 8);\n        i0.ɵɵnamespaceSVG();\n        i0.ɵɵelementStart(9, \"svg\", 9);\n        i0.ɵɵelement(10, \"path\", 10);\n        i0.ɵɵelementEnd();\n        i0.ɵɵnamespaceHTML();\n        i0.ɵɵelement(11, \"span\", 11);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(12, \"span\", 12, 13);\n        i0.ɵɵlistener(\"cdkObserveContent\", function MatCheckbox_Template_span_cdkObserveContent_12_listener() {\n          return ctx._onLabelTextChange();\n        });\n        i0.ɵɵelementStart(14, \"span\", 14);\n        i0.ɵɵtext(15, \"\\xA0\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(16);\n        i0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        const _r2 = i0.ɵɵreference(13);\n\n        i0.ɵɵattribute(\"for\", ctx.inputId);\n        i0.ɵɵadvance(2);\n        i0.ɵɵclassProp(\"mat-checkbox-inner-container-no-side-margin\", !_r2.textContent || !_r2.textContent.trim());\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"id\", ctx.inputId)(\"required\", ctx.required)(\"checked\", ctx.checked)(\"disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex);\n        i0.ɵɵattribute(\"value\", ctx.value)(\"name\", ctx.name)(\"aria-label\", ctx.ariaLabel || null)(\"aria-labelledby\", ctx.ariaLabelledby)(\"aria-checked\", ctx._getAriaChecked())(\"aria-describedby\", ctx.ariaDescribedby);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"matRippleTrigger\", _r0)(\"matRippleDisabled\", ctx._isRippleDisabled())(\"matRippleRadius\", 20)(\"matRippleCentered\", true)(\"matRippleAnimation\", i0.ɵɵpureFunction1(19, _c1, ctx._animationMode === \"NoopAnimations\" ? 0 : 150));\n      }\n    },\n    directives: [i2.MatRipple, i3.CdkObserveContent],\n    styles: [\"@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.910259}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);stroke-dashoffset:0}to{stroke-dashoffset:-22.910259}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0deg)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}32.8%,100%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{display:inline-block;transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.cdk-high-contrast-active .mat-checkbox.cdk-keyboard-focused .mat-checkbox-ripple{outline:solid 3px}.mat-checkbox-layout{-webkit-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0, 0, 0.2, 0.1),opacity 90ms cubic-bezier(0, 0, 0.2, 0.1);-webkit-print-color-adjust:exact;color-adjust:exact}._mat-animation-noopable .mat-checkbox-background{transition:none}.cdk-high-contrast-active .mat-checkbox .mat-checkbox-background{background:none}.mat-checkbox-persistent-ripple{display:block;width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media(hover: none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.910259;stroke-dasharray:22.910259;stroke-width:2.1333333333px}.cdk-high-contrast-black-on-white .mat-checkbox-checkmark-path{stroke:#000 !important}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0deg);border-radius:2px}.cdk-high-contrast-active .mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0deg)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.cdk-high-contrast-active .mat-checkbox-disabled{opacity:.5}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0ms mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0ms mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:300ms linear 0ms mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MatCheckbox;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst MAT_CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: /*#__PURE__*/forwardRef(() => MatCheckboxRequiredValidator),\n  multi: true\n};\n/**\n * Validator for Material checkbox's required attribute in template-driven checkbox.\n * Current CheckboxRequiredValidator only work with `input type=checkbox` and does not\n * work with `mat-checkbox`.\n */\n\nlet MatCheckboxRequiredValidator = /*#__PURE__*/(() => {\n  class MatCheckboxRequiredValidator extends CheckboxRequiredValidator {}\n\n  MatCheckboxRequiredValidator.ɵfac = /* @__PURE__ */function () {\n    let ɵMatCheckboxRequiredValidator_BaseFactory;\n    return function MatCheckboxRequiredValidator_Factory(t) {\n      return (ɵMatCheckboxRequiredValidator_BaseFactory || (ɵMatCheckboxRequiredValidator_BaseFactory = i0.ɵɵgetInheritedFactory(MatCheckboxRequiredValidator)))(t || MatCheckboxRequiredValidator);\n    };\n  }();\n\n  MatCheckboxRequiredValidator.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: MatCheckboxRequiredValidator,\n    selectors: [[\"mat-checkbox\", \"required\", \"\", \"formControlName\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"formControl\", \"\"], [\"mat-checkbox\", \"required\", \"\", \"ngModel\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([MAT_CHECKBOX_REQUIRED_VALIDATOR]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return MatCheckboxRequiredValidator;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** This module is used by both original and MDC-based checkbox implementations. */\n\n\nlet _MatCheckboxRequiredValidatorModule = /*#__PURE__*/(() => {\n  class _MatCheckboxRequiredValidatorModule {}\n\n  _MatCheckboxRequiredValidatorModule.ɵfac = function _MatCheckboxRequiredValidatorModule_Factory(t) {\n    return new (t || _MatCheckboxRequiredValidatorModule)();\n  };\n\n  _MatCheckboxRequiredValidatorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _MatCheckboxRequiredValidatorModule\n  });\n  _MatCheckboxRequiredValidatorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return _MatCheckboxRequiredValidatorModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MatCheckboxModule = /*#__PURE__*/(() => {\n  class MatCheckboxModule {}\n\n  MatCheckboxModule.ɵfac = function MatCheckboxModule_Factory(t) {\n    return new (t || MatCheckboxModule)();\n  };\n\n  MatCheckboxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MatCheckboxModule\n  });\n  MatCheckboxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[MatRippleModule, MatCommonModule, ObserversModule, _MatCheckboxRequiredValidatorModule], MatCommonModule, _MatCheckboxRequiredValidatorModule]\n  });\n  return MatCheckboxModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MAT_CHECKBOX_CONTROL_VALUE_ACCESSOR, MAT_CHECKBOX_DEFAULT_OPTIONS, MAT_CHECKBOX_DEFAULT_OPTIONS_FACTORY, MAT_CHECKBOX_REQUIRED_VALIDATOR, MatCheckbox, MatCheckboxChange, MatCheckboxModule, MatCheckboxRequiredValidator, _MatCheckboxRequiredValidatorModule }; //# sourceMappingURL=checkbox.mjs.map","map":null,"metadata":{},"sourceType":"module"}