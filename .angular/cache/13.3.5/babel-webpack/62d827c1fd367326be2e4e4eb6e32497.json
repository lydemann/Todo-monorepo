{"ast":null,"code":"import { createSelector } from '@ngrx/store';\nimport { isDevMode } from '@angular/core';\n\nfunction getInitialEntityState() {\n  return {\n    ids: [],\n    entities: {}\n  };\n}\n\nfunction createInitialStateFactory() {\n  function getInitialState(additionalState = {}) {\n    return Object.assign(getInitialEntityState(), additionalState);\n  }\n\n  return {\n    getInitialState\n  };\n}\n\nfunction createSelectorsFactory() {\n  function getSelectors(selectState) {\n    const selectIds = state => state.ids;\n\n    const selectEntities = state => state.entities;\n\n    const selectAll = createSelector(selectIds, selectEntities, (ids, entities) => ids.map(id => entities[id]));\n    const selectTotal = createSelector(selectIds, ids => ids.length);\n\n    if (!selectState) {\n      return {\n        selectIds,\n        selectEntities,\n        selectAll,\n        selectTotal\n      };\n    }\n\n    return {\n      selectIds: createSelector(selectState, selectIds),\n      selectEntities: createSelector(selectState, selectEntities),\n      selectAll: createSelector(selectState, selectAll),\n      selectTotal: createSelector(selectState, selectTotal)\n    };\n  }\n\n  return {\n    getSelectors\n  };\n}\n\nvar DidMutate = /*#__PURE__*/(() => {\n  (function (DidMutate) {\n    DidMutate[DidMutate[\"EntitiesOnly\"] = 0] = \"EntitiesOnly\";\n    DidMutate[DidMutate[\"Both\"] = 1] = \"Both\";\n    DidMutate[DidMutate[\"None\"] = 2] = \"None\";\n  })(DidMutate || (DidMutate = {}));\n\n  return DidMutate;\n})();\n\nfunction createStateOperator(mutator) {\n  return function operation(arg, state) {\n    const clonedEntityState = {\n      ids: [...state.ids],\n      entities: Object.assign({}, state.entities)\n    };\n    const didMutate = mutator(arg, clonedEntityState);\n\n    if (didMutate === DidMutate.Both) {\n      return Object.assign({}, state, clonedEntityState);\n    }\n\n    if (didMutate === DidMutate.EntitiesOnly) {\n      return Object.assign(Object.assign({}, state), {\n        entities: clonedEntityState.entities\n      });\n    }\n\n    return state;\n  };\n}\n\nfunction selectIdValue(entity, selectId) {\n  const key = selectId(entity);\n\n  if (isDevMode() && key === undefined) {\n    console.warn('@ngrx/entity: The entity passed to the `selectId` implementation returned undefined.', 'You should probably provide your own `selectId` implementation.', 'The entity that was passed:', entity, 'The `selectId` implementation:', selectId.toString());\n  }\n\n  return key;\n}\n\nfunction createUnsortedStateAdapter(selectId) {\n  function addOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n\n    if (key in state.entities) {\n      return DidMutate.None;\n    }\n\n    state.ids.push(key);\n    state.entities[key] = entity;\n    return DidMutate.Both;\n  }\n\n  function addManyMutably(entities, state) {\n    let didMutate = false;\n\n    for (const entity of entities) {\n      didMutate = addOneMutably(entity, state) !== DidMutate.None || didMutate;\n    }\n\n    return didMutate ? DidMutate.Both : DidMutate.None;\n  }\n\n  function setAllMutably(entities, state) {\n    state.ids = [];\n    state.entities = {};\n    addManyMutably(entities, state);\n    return DidMutate.Both;\n  }\n\n  function setOneMutably(entity, state) {\n    const key = selectIdValue(entity, selectId);\n\n    if (key in state.entities) {\n      state.entities[key] = entity;\n      return DidMutate.EntitiesOnly;\n    }\n\n    state.ids.push(key);\n    state.entities[key] = entity;\n    return DidMutate.Both;\n  }\n\n  function setManyMutably(entities, state) {\n    const didMutateSetOne = entities.map(entity => setOneMutably(entity, state));\n\n    switch (true) {\n      case didMutateSetOne.some(didMutate => didMutate === DidMutate.Both):\n        return DidMutate.Both;\n\n      case didMutateSetOne.some(didMutate => didMutate === DidMutate.EntitiesOnly):\n        return DidMutate.EntitiesOnly;\n\n      default:\n        return DidMutate.None;\n    }\n  }\n\n  function removeOneMutably(key, state) {\n    return removeManyMutably([key], state);\n  }\n\n  function removeManyMutably(keysOrPredicate, state) {\n    const keys = keysOrPredicate instanceof Array ? keysOrPredicate : state.ids.filter(key => keysOrPredicate(state.entities[key]));\n    const didMutate = keys.filter(key => key in state.entities).map(key => delete state.entities[key]).length > 0;\n\n    if (didMutate) {\n      state.ids = state.ids.filter(id => id in state.entities);\n    }\n\n    return didMutate ? DidMutate.Both : DidMutate.None;\n  }\n\n  function removeAll(state) {\n    return Object.assign({}, state, {\n      ids: [],\n      entities: {}\n    });\n  }\n\n  function takeNewKey(keys, update, state) {\n    const original = state.entities[update.id];\n    const updated = Object.assign({}, original, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    const hasNewKey = newKey !== update.id;\n\n    if (hasNewKey) {\n      keys[update.id] = newKey;\n      delete state.entities[update.id];\n    }\n\n    state.entities[newKey] = updated;\n    return hasNewKey;\n  }\n\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n\n  function updateManyMutably(updates, state) {\n    const newKeys = {};\n    updates = updates.filter(update => update.id in state.entities);\n    const didMutateEntities = updates.length > 0;\n\n    if (didMutateEntities) {\n      const didMutateIds = updates.filter(update => takeNewKey(newKeys, update, state)).length > 0;\n\n      if (didMutateIds) {\n        state.ids = state.ids.map(id => newKeys[id] || id);\n        return DidMutate.Both;\n      } else {\n        return DidMutate.EntitiesOnly;\n      }\n    }\n\n    return DidMutate.None;\n  }\n\n  function mapMutably(map, state) {\n    const changes = state.ids.reduce((changes, id) => {\n      const change = map(state.entities[id]);\n\n      if (change !== state.entities[id]) {\n        changes.push({\n          id,\n          changes: change\n        });\n      }\n\n      return changes;\n    }, []);\n    const updates = changes.filter(({\n      id\n    }) => id in state.entities);\n    return updateManyMutably(updates, state);\n  }\n\n  function mapOneMutably({\n    map,\n    id\n  }, state) {\n    const entity = state.entities[id];\n\n    if (!entity) {\n      return DidMutate.None;\n    }\n\n    const updatedEntity = map(entity);\n    return updateOneMutably({\n      id: id,\n      changes: updatedEntity\n    }, state);\n  }\n\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n\n  function upsertManyMutably(entities, state) {\n    const added = [];\n    const updated = [];\n\n    for (const entity of entities) {\n      const id = selectIdValue(entity, selectId);\n\n      if (id in state.entities) {\n        updated.push({\n          id,\n          changes: entity\n        });\n      } else {\n        added.push(entity);\n      }\n    }\n\n    const didMutateByUpdated = updateManyMutably(updated, state);\n    const didMutateByAdded = addManyMutably(added, state);\n\n    switch (true) {\n      case didMutateByAdded === DidMutate.None && didMutateByUpdated === DidMutate.None:\n        return DidMutate.None;\n\n      case didMutateByAdded === DidMutate.Both || didMutateByUpdated === DidMutate.Both:\n        return DidMutate.Both;\n\n      default:\n        return DidMutate.EntitiesOnly;\n    }\n  }\n\n  return {\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    addMany: createStateOperator(addManyMutably),\n    setAll: createStateOperator(setAllMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    removeOne: createStateOperator(removeOneMutably),\n    removeMany: createStateOperator(removeManyMutably),\n    map: createStateOperator(mapMutably),\n    mapOne: createStateOperator(mapOneMutably)\n  };\n}\n\nfunction createSortedStateAdapter(selectId, sort) {\n  const {\n    removeOne,\n    removeMany,\n    removeAll\n  } = createUnsortedStateAdapter(selectId);\n\n  function addOneMutably(entity, state) {\n    return addManyMutably([entity], state);\n  }\n\n  function addManyMutably(newModels, state) {\n    const models = newModels.filter(model => !(selectIdValue(model, selectId) in state.entities));\n\n    if (models.length === 0) {\n      return DidMutate.None;\n    } else {\n      merge(models, state);\n      return DidMutate.Both;\n    }\n  }\n\n  function setAllMutably(models, state) {\n    state.entities = {};\n    state.ids = [];\n    addManyMutably(models, state);\n    return DidMutate.Both;\n  }\n\n  function setOneMutably(entity, state) {\n    const id = selectIdValue(entity, selectId);\n\n    if (id in state.entities) {\n      state.ids = state.ids.filter(val => val !== id);\n      merge([entity], state);\n      return DidMutate.Both;\n    } else {\n      return addOneMutably(entity, state);\n    }\n  }\n\n  function setManyMutably(entities, state) {\n    const didMutateSetOne = entities.map(entity => setOneMutably(entity, state));\n\n    switch (true) {\n      case didMutateSetOne.some(didMutate => didMutate === DidMutate.Both):\n        return DidMutate.Both;\n\n      case didMutateSetOne.some(didMutate => didMutate === DidMutate.EntitiesOnly):\n        return DidMutate.EntitiesOnly;\n\n      default:\n        return DidMutate.None;\n    }\n  }\n\n  function updateOneMutably(update, state) {\n    return updateManyMutably([update], state);\n  }\n\n  function takeUpdatedModel(models, update, state) {\n    if (!(update.id in state.entities)) {\n      return false;\n    }\n\n    const original = state.entities[update.id];\n    const updated = Object.assign({}, original, update.changes);\n    const newKey = selectIdValue(updated, selectId);\n    delete state.entities[update.id];\n    models.push(updated);\n    return newKey !== update.id;\n  }\n\n  function updateManyMutably(updates, state) {\n    const models = [];\n    const didMutateIds = updates.filter(update => takeUpdatedModel(models, update, state)).length > 0;\n\n    if (models.length === 0) {\n      return DidMutate.None;\n    } else {\n      const originalIds = state.ids;\n      const updatedIndexes = [];\n      state.ids = state.ids.filter((id, index) => {\n        if (id in state.entities) {\n          return true;\n        } else {\n          updatedIndexes.push(index);\n          return false;\n        }\n      });\n      merge(models, state);\n\n      if (!didMutateIds && updatedIndexes.every(i => state.ids[i] === originalIds[i])) {\n        return DidMutate.EntitiesOnly;\n      } else {\n        return DidMutate.Both;\n      }\n    }\n  }\n\n  function mapMutably(updatesOrMap, state) {\n    const updates = state.ids.reduce((changes, id) => {\n      const change = updatesOrMap(state.entities[id]);\n\n      if (change !== state.entities[id]) {\n        changes.push({\n          id,\n          changes: change\n        });\n      }\n\n      return changes;\n    }, []);\n    return updateManyMutably(updates, state);\n  }\n\n  function mapOneMutably({\n    map,\n    id\n  }, state) {\n    const entity = state.entities[id];\n\n    if (!entity) {\n      return DidMutate.None;\n    }\n\n    const updatedEntity = map(entity);\n    return updateOneMutably({\n      id: id,\n      changes: updatedEntity\n    }, state);\n  }\n\n  function upsertOneMutably(entity, state) {\n    return upsertManyMutably([entity], state);\n  }\n\n  function upsertManyMutably(entities, state) {\n    const added = [];\n    const updated = [];\n\n    for (const entity of entities) {\n      const id = selectIdValue(entity, selectId);\n\n      if (id in state.entities) {\n        updated.push({\n          id,\n          changes: entity\n        });\n      } else {\n        added.push(entity);\n      }\n    }\n\n    const didMutateByUpdated = updateManyMutably(updated, state);\n    const didMutateByAdded = addManyMutably(added, state);\n\n    switch (true) {\n      case didMutateByAdded === DidMutate.None && didMutateByUpdated === DidMutate.None:\n        return DidMutate.None;\n\n      case didMutateByAdded === DidMutate.Both || didMutateByUpdated === DidMutate.Both:\n        return DidMutate.Both;\n\n      default:\n        return DidMutate.EntitiesOnly;\n    }\n  }\n\n  function merge(models, state) {\n    models.sort(sort);\n    const ids = [];\n    let i = 0;\n    let j = 0;\n\n    while (i < models.length && j < state.ids.length) {\n      const model = models[i];\n      const modelId = selectIdValue(model, selectId);\n      const entityId = state.ids[j];\n      const entity = state.entities[entityId];\n\n      if (sort(model, entity) <= 0) {\n        ids.push(modelId);\n        i++;\n      } else {\n        ids.push(entityId);\n        j++;\n      }\n    }\n\n    if (i < models.length) {\n      state.ids = ids.concat(models.slice(i).map(selectId));\n    } else {\n      state.ids = ids.concat(state.ids.slice(j));\n    }\n\n    models.forEach((model, i) => {\n      state.entities[selectId(model)] = model;\n    });\n  }\n\n  return {\n    removeOne,\n    removeMany,\n    removeAll,\n    addOne: createStateOperator(addOneMutably),\n    updateOne: createStateOperator(updateOneMutably),\n    upsertOne: createStateOperator(upsertOneMutably),\n    setAll: createStateOperator(setAllMutably),\n    setOne: createStateOperator(setOneMutably),\n    setMany: createStateOperator(setManyMutably),\n    addMany: createStateOperator(addManyMutably),\n    updateMany: createStateOperator(updateManyMutably),\n    upsertMany: createStateOperator(upsertManyMutably),\n    map: createStateOperator(mapMutably),\n    mapOne: createStateOperator(mapOneMutably)\n  };\n}\n\nfunction createEntityAdapter(options = {}) {\n  const {\n    selectId,\n    sortComparer\n  } = Object.assign({\n    sortComparer: false,\n    selectId: instance => instance.id\n  }, options);\n  const stateFactory = createInitialStateFactory();\n  const selectorsFactory = createSelectorsFactory();\n  const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n  return Object.assign(Object.assign(Object.assign({\n    selectId,\n    sortComparer\n  }, stateFactory), selectorsFactory), stateAdapter);\n}\n\nclass Dictionary {}\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Dictionary, createEntityAdapter };","map":null,"metadata":{},"sourceType":"module"}