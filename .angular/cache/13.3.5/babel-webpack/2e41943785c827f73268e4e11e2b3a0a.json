{"ast":null,"code":"import * as moment from 'moment';\nimport { Subject } from 'rxjs';\nimport { debounceTime, filter } from 'rxjs/operators';\nvar LoggerEvents = /*#__PURE__*/(() => {\n  (function (LoggerEvents) {\n    LoggerEvents[LoggerEvents[\"Flush\"] = 1] = \"Flush\";\n  })(LoggerEvents || (LoggerEvents = {}));\n\n  return LoggerEvents;\n})();\nexport class Logger {\n  constructor(appName, logEndpoint, isProd = false) {\n    this.appName = appName;\n    this.logEndpoint = logEndpoint;\n    this.isProd = isProd;\n    this.APP_FIELD = 'Application';\n    this.ENV_FIELD = 'Environment';\n    this.VERSION_FIELD = 'Version';\n    this.USER_NAME_FIELD = 'UserName';\n    this.ELAPSED_MS_FIELD = 'ElapsedMilliseconds';\n    this.REQUEST_PATH_FIELD = 'RequestPath';\n    this.URL_FIELD = 'Url';\n    this.APP_STATE_FIELD = 'AppState';\n    this.buffer = [];\n    this.flush = new Subject();\n    this.flush.pipe(debounceTime(5000), filter(event => event === LoggerEvents.Flush)).subscribe(() => this.flushBuffer());\n  }\n\n  log(type, message, data) {\n    this.buffer.push({\n      type,\n      message,\n      data\n    });\n    this.flush.next(LoggerEvents.Flush);\n  }\n\n  flushBuffer() {\n    const data = this.buffer.splice(0);\n\n    if (data.length === 0) {\n      return;\n    }\n\n    const body = data.map(entry => this.buildLogString(entry)).reduce((sum, entry) => sum += entry, '');\n\n    if (!this.isProd) {\n      // This is nested to make sure we always end up in here when running locally\n      // as in do not && this to the above if...\n      // tslint:disable-next-line:no-console\n      console.log({\n        body,\n        data\n      });\n    } else {\n      const xobj = new XMLHttpRequest(); // tslint:disable-next-line:no-console\n\n      xobj.onerror = err => console.error(err);\n\n      xobj.open('POST', this.logEndpoint, true);\n      xobj.send(body);\n    }\n  }\n\n  buildLogString(entry) {\n    const index = this.buildIndexChunk();\n    const body = this.buildBodyChunk(entry);\n    return `${index}\\n${body}\\n`;\n  }\n\n  buildIndexChunk() {\n    const date = moment();\n    const index = {\n      index: {\n        _index: `logstash-${date.format('YYYY.M.D')}`,\n        _type: 'logevent'\n      }\n    };\n    return this.safeStringify(index);\n  }\n\n  safeStringify(value) {\n    const seen = new Set();\n    return JSON.stringify(value, (k, v) => {\n      if (seen.has(v)) {\n        return '...';\n      }\n\n      if (typeof v === 'object') {\n        seen.add(v);\n      }\n\n      return v;\n    });\n  }\n\n  buildBodyChunk(entry) {\n    const {\n      type,\n      message,\n      data\n    } = entry;\n    const level = type;\n    const date = moment();\n    const messageTemplate = this.getMessageTemplate();\n    const fields = this.getFields(data);\n    const body = {\n      '@timestamp': `${date.toISOString()}`,\n      level,\n      messageTemplate,\n      message,\n      fields\n    };\n    return body;\n  }\n\n  getMessageTemplate() {\n    const fields = [this.APP_FIELD, this.ENV_FIELD, this.VERSION_FIELD, this.USER_NAME_FIELD, this.ELAPSED_MS_FIELD, this.REQUEST_PATH_FIELD, this.URL_FIELD, this.APP_STATE_FIELD];\n    const template = fields.map(field => `{${field}}`).join(' - ');\n    return template;\n  }\n\n  getFields(data) {\n    return {\n      [this.APP_FIELD]: this.appName,\n      [this.ENV_FIELD]: data.environment,\n      [this.VERSION_FIELD]: data.appVersion,\n      [this.USER_NAME_FIELD]: data.userId,\n      [this.ELAPSED_MS_FIELD]: data.elapsedTime,\n      [this.REQUEST_PATH_FIELD]: data.requestPath,\n      [this.URL_FIELD]: data.url,\n      [this.APP_STATE_FIELD]: data.state\n    };\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}